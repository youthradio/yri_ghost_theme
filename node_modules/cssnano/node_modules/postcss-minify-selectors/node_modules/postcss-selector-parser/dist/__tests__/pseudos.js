'use strict';

var _utilHelpers = require('./util/helpers');

(0, _utilHelpers.test)('pseudo element (single colon)', 'h1:after', function (t, tree) {
    t.plan(3);
    t.equal(tree.nodes[0].nodes[0].type, 'tag');
    t.equal(tree.nodes[0].nodes[1].type, 'pseudo');
    t.equal(tree.nodes[0].nodes[1].value, ':after');
});

(0, _utilHelpers.test)('pseudo element (double colon)', 'h1::after', function (t, tree) {
    t.plan(3);
    t.equal(tree.nodes[0].nodes[0].type, 'tag');
    t.equal(tree.nodes[0].nodes[1].type, 'pseudo');
    t.equal(tree.nodes[0].nodes[1].value, '::after');
});

(0, _utilHelpers.test)('multiple pseudo elements', '*:target::before, a:after', function (t, tree) {
    t.plan(4);
    t.equal(tree.nodes[0].nodes[0].value, '*');
    t.equal(tree.nodes[0].nodes[1].value, ':target');
    t.equal(tree.nodes[0].nodes[2].value, '::before');
    t.equal(tree.nodes[1].nodes[1].value, ':after');
});

(0, _utilHelpers.test)('negation pseudo element', 'h1:not(.heading)', function (t, tree) {
    t.plan(2);
    t.equal(tree.nodes[0].nodes[1].value, ':not');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].value, 'heading');
});

(0, _utilHelpers.test)('negation pseudo element (2)', 'h1:not(.heading, .title, .content)', function (t, tree) {
    t.plan(4);
    t.equal(tree.nodes[0].nodes[1].value, ':not');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].value, 'heading');
    t.equal(tree.nodes[0].nodes[1].nodes[1].nodes[0].value, 'title');
    t.equal(tree.nodes[0].nodes[1].nodes[2].nodes[0].value, 'content');
});

(0, _utilHelpers.test)('negation pseudo element (3)', 'h1:not(.heading > .title) > h1', function (t, tree) {
    t.plan(5);
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].value, 'heading');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[1].value, '>');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[2].value, 'title');
    t.equal(tree.nodes[0].nodes[2].value, '>');
    t.equal(tree.nodes[0].nodes[3].value, 'h1');
});

(0, _utilHelpers.test)('negation pseudo element (4)', 'h1:not(h2:not(h3))', function (t, tree) {
    t.plan(2);
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[1].nodes[0].nodes[0].value, 'h3');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[1].nodes[0].nodes[0].parent.type, 'selector');
});

(0, _utilHelpers.test)('pseudo class in the middle of a selector', 'a:link.external', function (t, tree) {
    t.plan(6);
    t.equal(tree.nodes[0].nodes[0].type, 'tag');
    t.equal(tree.nodes[0].nodes[0].value, 'a');
    t.equal(tree.nodes[0].nodes[1].type, 'pseudo');
    t.equal(tree.nodes[0].nodes[1].value, ':link');
    t.equal(tree.nodes[0].nodes[2].type, 'class');
    t.equal(tree.nodes[0].nodes[2].value, 'external');
});

(0, _utilHelpers.test)('extra whitespace inside parentheses', 'a:not(   h2   )', function (t, tree) {
    t.plan(3);
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].value, 'h2');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].spaces.after, '   ');
    t.equal(tree.nodes[0].nodes[1].nodes[0].nodes[0].spaces.before, '   ');
});

(0, _utilHelpers.test)('escaped numbers in class name with pseudo', 'a:before.\\31\\ 0', function (t, tree, d) {
    t.plan(2);
    t.equal(tree.nodes[0].nodes[2].type, 'class');
    t.equal(tree.nodes[0].nodes[2].value, '\\31\\ 0');
});

(0, _utilHelpers.test)('extraneous non-combinating whitespace', '  h1:after   ,  h2:after   ', function (t, tree) {
    t.plan(6);
    t.equal(tree.nodes[0].nodes[0].spaces.before, '  ');
    t.equal(tree.nodes[0].nodes[1].value, ':after');
    t.equal(tree.nodes[0].nodes[1].spaces.after, '   ');
    t.equal(tree.nodes[0].nodes[0].spaces.before, '  ');
    t.equal(tree.nodes[1].nodes[1].value, ':after');
    t.equal(tree.nodes[1].nodes[1].spaces.after, '   ');
});